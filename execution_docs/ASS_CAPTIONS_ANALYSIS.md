# ASS Caption Editor - Comprehensive Analysis & Debug Report

**Date**: 2026-02-17
**Status**: Critical bugs identified in save/compose pipeline

---

## Executive Summary

The ASS caption editor has **critical serialization bugs** that cause:
1. **Malformed ASS files** saved to storage (extra comma in Style lines)
2. **Loss of karaoke/focus tags** when editing text
3. **Mismatch between editor preview and final composed video**

The editor preview renders captions correctly in the browser, but the serialized ASS file sent to FFmpeg has formatting issues that cause different rendering in the final video.

---

## 1. Data Flow Overview

### Generation ‚Üí Editing ‚Üí Composition Pipeline

```
1. Generate Captions (TTS + WhisperX)
   ‚Üì
   lib/captions/ass-generator.ts
   ‚îú‚îÄ generateASS() creates valid ASS with karaoke tags
   ‚îú‚îÄ Example: {\k18}Hey{\k14}my{\k26}name{\r\k8\fs70\c&H00FFFF&}is{\r}{\k52}Pulomi,
   ‚îî‚îÄ Saved to storage: projects/{userId}/{projectId}/captions/{timestamp}.ass

2. Edit Captions
   ‚Üì
   components/studio/ASSEditorModal.tsx
   ‚îú‚îÄ parseASS() loads ASS into editor state
   ‚îú‚îÄ User edits text/timing/position
   ‚îú‚îÄ Preview renders correctly in browser (VideoPlayer.tsx)
   ‚îî‚îÄ Save Draft ‚Üí serializeASS() ‚Üí storage (BUG HERE)

3. Compose Video
   ‚Üì
   app/api/video/compose/route.ts
   ‚îú‚îÄ Fetches ASS from storage
   ‚îú‚îÄ Sends to FFmpeg API
   ‚îî‚îÄ FFmpeg applies ASS using ass= filter
       ‚Üì
       modal_apis/ffmpeg_api/src/ffmpeg_ops.py:232-234
       ‚îî‚îÄ subtitle_filter = f"ass={temp_subtitle}"
```

### Original Generated ASS (Correct)

```ass
[Script Info]
; Script generated by Reel Story Studio
Title: Reel Story Studio Captions
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709
PlayResX: 1080
PlayResY: 1920

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TikTok,Impact,60,&H00FFFFFF&,&H0040DDFE&,&H00000000&,&H80000000&,-1,0,0,0,100,100,0,0,1,4,2,2,50,50,50,1
Style: Focus,Impact,70,&H00FFFF00&,&H00EEF425&,&H00000000&,&H96000000&,-1,0,0,0,100,100,2,0,1,5,3,2,50,50,60,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.49,TikTok,,0,0,0,,{\k18}Hey{\k14}my{\k26}name{\r\k8\fs70\c&H00FFFF&}is{\r}{\k52}Pulomi,
Dialogue: 0,0:00:01.79,0:00:02.11,TikTok,,0,0,0,,{\k32}ka.
```

### After Save Draft (BROKEN)

```ass
[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style:,TikTok,Impact,60,...  ‚Üê EXTRA COMMA AFTER "Style:"
Style:,Focus,Impact,70,...    ‚Üê EXTRA COMMA AFTER "Style:"

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:02.10,TikTok,,0,0,0,,Hey my name is Poulomi Kha.  ‚Üê ALL TAGS LOST
Dialogue: 0,0:00:02.71,0:00:03.50,TikTok,,0,0,0,,{\r\k12\fs70\c&H00FFFF&}How{\r}{\k10}are{\k10}you{\k26}doing?
```

**Issues:**
1. ‚ùå `Style:,TikTok` ‚Üí Should be `Style: TikTok` (no comma after colon)
2. ‚ùå First dialogue lost all karaoke tags: `Hey my name is Poulomi Kha.`
3. ‚úÖ Other dialogues retained tags (because text wasn't changed)

---

## 2. Critical Bugs Identified

### üêõ Bug #1: serializeStyle() - Extra Comma (CRITICAL)

**Location**: `lib/captions/ass-parser.ts:494-520`

**Issue**: The serializeStyle function creates malformed Style lines:

```typescript
function serializeStyle(style: ASSStyle): string {
  return [
    'Style:',           // ‚Üê This adds "Style:" as first element
    style.Name,         // ‚Üê This adds "TikTok" as second element
    style.Fontname,
    // ... rest
  ].join(',')          // ‚Üê join(',') creates: "Style:,TikTok,Impact,..."
}
```

**Result**:
- Browser: `Style:,TikTok,Impact,60,...`
- FFmpeg expects: `Style: TikTok,Impact,60,...`

**Impact**:
- FFmpeg may fail to parse styles correctly
- Captions render differently in final video vs preview

**Fix**:
```typescript
function serializeStyle(style: ASSStyle): string {
  const values = [
    style.Name,
    style.Fontname,
    style.Fontsize,
    // ... all other fields
  ].join(',')

  return `Style: ${values}`  // ‚Üê Add space after colon, don't join with values
}
```

---

### üêõ Bug #2: rebuildASSText() - Losing Karaoke Tags

**Location**: `lib/captions/ass-parser.ts:328-395`

**Issue**: When user edits caption text, the `rebuildASSText()` function should preserve karaoke tags but fails in some cases.

**Flow**:
1. User types new text in editor sidebar
2. `EditorSidebar` calls `onUpdateCaption(index, { text: newPlainText })`
3. Editor reducer updates `caption.text` directly with plain text
4. **BUG**: No call to `rebuildASSText()` to preserve tags!

**Expected Behavior**:
```typescript
// User types "Hey my name is Poulomi Kha."
// Should preserve original karaoke structure:
{\k18}Hey{\k14}my{\k26}name{\r\k8\fs70\c&H00FFFF&}is{\r}{\k52}Poulomi,{\k32}ka.

// Instead, we get:
Hey my name is Poulomi Kha.  // All tags lost!
```

**Root Cause**:
The `rebuildASSText()` function is only called when:
1. Text changes AND
2. The function decides to preserve structure

But in `ASSEditorModal.tsx`, the text update flow bypasses `rebuildASSText()`:

```typescript
// ASSEditorModal.tsx:893
onUpdateCaption={(index, updates) =>
  dispatch({ type: 'UPDATE_CAPTION', index, caption: updates })
}

// This directly sets caption.text = updates.text (plain text)
// No call to rebuildASSText() to wrap it with tags!
```

**Fix Required**:
When updating caption text from editor sidebar, we need to:
1. Get the original caption.text (with tags)
2. Call `rebuildASSText(newPlainText, originalText)`
3. Update caption.text with the result (preserving tags)

---

### üêõ Bug #3: Split/Merge Operations Lose ASS Tags

**Location**: `components/studio/ASSEditorModal.tsx:544-608`

**Issue**: The Split and Merge caption operations bypass `rebuildASSText()` and set plain text directly.

**Evidence from EditorSidebar.tsx:556-566**:
```typescript
<textarea
  value={textValue}
  onChange={(event) => {
    const nextValue = event.target.value
    setTextValue(nextValue)
    const nextText = rebuildASSText(nextValue, selectedCaption.text)  // ‚úÖ CORRECT!
    onUpdateCaption(selectedCaption.index, {
      plainText: nextValue,
      text: nextText,  // ‚Üê Preserves tags
    })
  }}
/>
```
**Text editing via textarea IS correct** - it calls `rebuildASSText()`.

**But Split operation (line 571-582)**:
```typescript
const updatedFirst: ParsedCaption = {
  ...caption,
  end: splitTime,
  text: firstText,       // ‚Üê BUG! Plain text, no tags
  plainText: firstText,
}
const updatedSecond: ParsedCaption = {
  ...caption,
  start: splitTime,
  text: secondText,      // ‚Üê BUG! Plain text, no tags
  plainText: secondText,
}
```

**And Merge operation (line 598-604)**:
```typescript
const mergedText = `${current.plainText || current.text} ${next.plainText || next.text}`.trim()
const merged: ParsedCaption = {
  ...current,
  end: next.end,
  text: mergedText,      // ‚Üê BUG! Plain text, no tags
  plainText: mergedText,
}
```

**User's Scenario**:
1. Generated captions have karaoke tags: `{\k18}Hey{\k14}my...`
2. User clicks "Merge Next" to combine two captions
3. Merge uses `plainText` (no tags) from both captions
4. Result: `text: "Hey my name is Poulomi Kha."` (all tags lost)

**What Should Happen**:
```typescript
// Split operation
const originalText = caption.text
const firstTextWithTags = rebuildASSText(firstText, originalText)
const secondTextWithTags = rebuildASSText(secondText, originalText)

const updatedFirst: ParsedCaption = {
  ...caption,
  end: splitTime,
  text: firstTextWithTags,   // ‚Üê Preserves karaoke structure
  plainText: firstText,
}
// ...

// Merge operation
const mergedPlainText = `${current.plainText || current.text} ${next.plainText || next.text}`.trim()
const combinedOriginal = `${current.text} ${next.text}`
const mergedTextWithTags = rebuildASSText(mergedPlainText, combinedOriginal)

const merged: ParsedCaption = {
  ...current,
  end: next.end,
  text: mergedTextWithTags,  // ‚Üê Preserves karaoke structure
  plainText: mergedPlainText,
}
```

---

### üêõ Bug #4: FFmpeg ASS Parsing - Vague Error Messages

**Location**: `modal_apis/ffmpeg_api/src/ffmpeg_ops.py:199-268`

**Current Code**:
```python
async def overlay_subtitles(
    video_url: str,
    subtitle_url: str,
    output_path: str,
    subtitle_format: str = "ass",
    font_size: Optional[int] = None
) -> str:
    # ... download subtitle ...

    if subtitle_format == "ass":
        subtitle_filter = f"ass={temp_subtitle}"  # Line 233

    # ... ffmpeg command ...
    run_ffmpeg_command(command, timeout=900)

    # ... return output_path ...
```

**Issue**: The FFmpeg API has no validation of the ASS file before processing. When malformed ASS is sent:

1. **FFmpeg fails with cryptic errors** like:
   - "Error while opening encoder for output stream"
   - "Invalid data found when processing input"
   - "Subtitle encoding failed"

2. **No specific details** about what's wrong:
   - Which line has the error?
   - What format was expected?
   - Was it a Style line? Dialogue line? Header?

3. **Front-end gets vague 500 error**:
   ```json
   { "error": "Subtitle overlay failed: Command failed" }
   ```

**What the user sees**:
- "Failed to compose video" ‚Üí NO idea what to fix
- Has to debug blind ‚Üí download ASS, inspect manually, test locally

**What SHOULD happen**:
```json
{
  "error": "ASS format error",
  "details": "Malformed Style line at line 12",
  "line": "Style:,TikTok,Impact,60,...",
  "expected": "Style: Name,Fontname,Fontsize,...",
  "code": "ASS_PARSE_ERROR"
}
```

**Recommended Fix**:

Add ASS validation BEFORE calling FFmpeg:

```python
# modal_apis/ffmpeg_api/src/ffmpeg_ops.py

def validate_ass_format(filepath: str) -> dict:
    """
    Validate ASS file format and return detailed errors.

    Returns:
        dict with 'valid' (bool) and 'errors' (list of dicts)
    """
    errors = []

    try:
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            lines = f.readlines()

        in_styles = False
        in_events = False
        style_format = []
        event_format = []

        for line_num, line in enumerate(lines, 1):
            stripped = line.strip()

            # Check section headers
            if stripped.startswith('[V4+ Styles]'):
                in_styles = True
                in_events = False
                continue
            elif stripped.startswith('[Events]'):
                in_styles = False
                in_events = True
                continue
            elif stripped.startswith('['):
                in_styles = False
                in_events = False
                continue

            # Validate Style lines
            if in_styles and stripped.startswith('Style:'):
                # Check for extra comma after colon
                if stripped.startswith('Style:,'):
                    errors.append({
                        'line_num': line_num,
                        'line': stripped[:50],
                        'error': 'Malformed Style line: extra comma after "Style:"',
                        'expected': 'Style: Name,Fontname,...',
                        'fix': 'Remove comma after colon'
                    })

                # Check field count
                parts = stripped.split(',')
                if len(style_format) > 0 and len(parts) != len(style_format) + 1:
                    errors.append({
                        'line_num': line_num,
                        'line': stripped[:50],
                        'error': f'Style has {len(parts)} fields, expected {len(style_format) + 1}',
                        'expected': f'Format has {len(style_format)} fields'
                    })

            # Validate Dialogue lines
            if in_events and stripped.startswith('Dialogue:'):
                # Check if has minimum fields
                parts = stripped.split(',', 9)  # Max 9 commas before Text field
                if len(parts) < 10:
                    errors.append({
                        'line_num': line_num,
                        'line': stripped[:50],
                        'error': 'Dialogue line has too few fields',
                        'expected': 'Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text'
                    })

                # Warn if no karaoke tags
                text_field = parts[-1] if len(parts) >= 10 else ''
                if not re.search(r'\\k\d+', text_field, re.IGNORECASE):
                    # Don't error, but log warning
                    pass

            # Store formats
            if stripped.startswith('Format:'):
                fields = stripped.replace('Format:', '').strip().split(',')
                fields = [f.strip() for f in fields]

                if in_styles:
                    style_format = fields
                elif in_events:
                    event_format = fields

        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'warnings': []
        }

    except Exception as e:
        return {
            'valid': False,
            'errors': [{
                'error': f'Failed to parse ASS file: {str(e)}',
                'line_num': 0
            }]
        }

async def overlay_subtitles(
    video_url: str,
    subtitle_url: str,
    output_path: str,
    subtitle_format: str = "ass",
    font_size: Optional[int] = None
) -> str:
    temp_video = os.path.join(TEMP_PATH, "subtitle_video.mp4")
    temp_subtitle = os.path.join(TEMP_PATH, f"subtitle.{subtitle_format}")

    try:
        # Download video and subtitle
        await download_file(video_url, temp_video)
        await download_file(subtitle_url, temp_subtitle)

        # VALIDATE ASS FORMAT BEFORE PROCESSING
        if subtitle_format == "ass":
            validation = validate_ass_format(temp_subtitle)

            if not validation['valid']:
                # Build detailed error message
                error_details = validation['errors'][:3]  # Show first 3 errors
                error_msg = "ASS format validation failed:\n"
                for err in error_details:
                    error_msg += f"  Line {err.get('line_num', '?')}: {err['error']}\n"
                    if 'expected' in err:
                        error_msg += f"    Expected: {err['expected']}\n"

                raise ValueError(error_msg)

        # Proceed with FFmpeg processing...
        # ... rest of function ...
```

**API Response Enhancement**:

```python
# modal_apis/ffmpeg_api/src/routes.py

@app.post("/ops/overlay-subtitles", response_model=OperationResponse, tags=["Operations"])
async def overlay_subtitles_endpoint(body: OverlaySubtitlesRequest, request: Request):
    """Burn subtitles into video"""
    start_time = time.time()

    try:
        output_filename = generate_unique_filename("subtitled", "mp4")
        output_path = os.path.join(OUTPUTS_PATH, output_filename)

        await overlay_subtitles(
            body.video_url.unicode_string(),
            body.subtitle_url.unicode_string(),
            output_path,
            subtitle_format=body.subtitle_format,
            font_size=body.font_size
        )

        # ... success response ...

    except ValueError as e:
        # ASS validation error - return 400 with details
        error_msg = str(e)
        if "ASS format validation failed" in error_msg:
            return HTTPException(
                status_code=400,
                detail={
                    "error": "Invalid ASS format",
                    "message": error_msg,
                    "code": "ASS_VALIDATION_ERROR"
                }
            )
        raise

    except Exception as e:
        # Other errors
        raise HTTPException(
            status_code=500,
            detail=f"Subtitle overlay failed: {str(e)}"
        )
```

**Front-end Handling**:

```typescript
// app/api/video/compose/route.ts

try {
  const ffmpegResult = await composeReel({
    // ...
    subtitles_url: resolvedSubtitlesUrl,
    subtitle_format: 'ass',
  })
} catch (error) {
  // Parse FFmpeg API error
  const message = error instanceof Error ? error.message : 'Unknown error'

  if (message.includes('ASS format validation failed')) {
    return NextResponse.json(
      {
        error: 'Caption format error',
        details: message,
        suggestion: 'Please re-save your captions in the editor before composing.',
      },
      { status: 400 }
    )
  }

  return NextResponse.json(
    { error: 'Failed to compose video', details: message },
    { status: 500 }
  )
}
```

**Benefits**:
- ‚úÖ Clear, actionable error messages
- ‚úÖ Line numbers and specific issues
- ‚úÖ User knows what to fix
- ‚úÖ Proper HTTP status codes (400 vs 500)
- ‚úÖ Prevents wasted FFmpeg processing time

---

### üêõ Bug #5: Save Draft Silent Failures

**Location**: `components/studio/ASSEditorModal.tsx:355-386`

**Issue**: The save-to-storage flow can fail silently:

```typescript
fetch('/api/captions/save', {
  method: 'POST',
  // ...
})
.then(async (response) => {
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to save captions')
  }
  return response.json()
})
.then((data: { assUrl: string }) => {
  if (data.assUrl) {
    _onSave(data.assUrl)  // ‚Üê Updates parent state with new URL
  }
  toast({ title: 'Draft synced', description: '...' })
})
.catch((error) => {
  console.error('Failed to sync ASS:', error)
  toast({ title: 'Draft sync failed', variant: 'destructive' })
})
```

**Problem**:
1. Local storage is updated immediately (line 329)
2. Storage upload happens in background
3. If upload fails, local storage has changes but storage doesn't
4. Next compose will use OLD captions from storage

**Fix**:
Option A: Block on upload (show loading)
Option B: Show clear warning if upload fails

---

## 3. Why Preview Works but Video Doesn't

The editor preview (VideoPlayer.tsx) **directly parses** the in-memory ASS structure and renders it on canvas using correct parsing logic:

```typescript
// VideoPlayer.tsx:97-175
const parseASSText = (rawText: string) => {
  // Correctly handles:
  // - {\k18} karaoke tags
  // - {\r\k8\fs70\c&H00FFFF&} inline style overrides
  // - Spacing between segments
  // Returns segments with overrides for canvas rendering
}
```

**But FFmpeg receives**:
- Serialized ASS file from storage
- With malformed Style lines
- With plain text dialogues (no karaoke tags)

**Result**: FFmpeg renders captions differently than browser preview.

---

## 4. Complete Save ‚Üí Compose Flow (Current State)

```
1. User edits caption text in sidebar
   ‚Üì
   EditorSidebar calls: onUpdateCaption(index, { text: "Hey my name..." })
   ‚Üì
   Reducer UPDATE_CAPTION: caption.text = "Hey my name..." (plain text)
   ‚Üì
   [BUG: No tag preservation]

2. User clicks "Save Draft"
   ‚Üì
   serializeASS(state.parsed) is called
   ‚Üì
   serializeStyle() creates: "Style:,TikTok,..." [BUG]
   serializeDialogue() outputs: "Dialogue: 0,0:00:00.03,0:00:02.10,TikTok,,0,0,0,,Hey my name..."
   ‚Üì
   Saved to localStorage
   ‚Üì
   POST /api/captions/save
   ‚Üì
   Upload to Supabase storage (may fail silently)

3. User clicks "Compose Video"
   ‚Üì
   POST /api/video/compose
   ‚Üì
   Fetches ASS from storage (malformed)
   ‚Üì
   Sends to FFmpeg API: compose_reel(..., subtitles_url=malformed.ass)
   ‚Üì
   FFmpeg downloads malformed.ass
   ‚Üì
   FFmpeg applies: -vf ass=malformed.ass
   ‚Üì
   FFmpeg parses with errors:
   - Style line has extra comma ‚Üí may skip style or parse incorrectly
   - Dialogue has no karaoke tags ‚Üí renders as plain static text
   ‚Üì
   Video looks different than preview
```

---

## 5. Testing Evidence

### User's Provided Examples

**Original Generated ASS** (correct):
```
Dialogue: 0,0:00:00.03,0:00:01.49,TikTok,,0,0,0,,{\k18}Hey{\k14}my{\k26}name{\r\k8\fs70\c&H00FFFF&}is{\r}{\k52}Pulomi,
```

**After Save Draft** (broken):
```
Dialogue: 0,0:00:00.03,0:00:02.10,TikTok,,0,0,0,,Hey my name is Poulomi Kha.
```

**Observations**:
1. ‚úÖ Timing changed: 0:00:01.49 ‚Üí 0:00:02.10 (user merged lines)
2. ‚ùå All karaoke tags lost: `{\k18}Hey{\k14}my...` ‚Üí `Hey my name...`
3. ‚ùå Focus word styling lost: `{\r\k8\fs70\c&H00FFFF&}is{\r}` ‚Üí `is`
4. ‚ùå Style line has extra comma: `Style:,TikTok` ‚Üí FFmpeg parse error

---

## 6. UX Complexity Issue - Editor Overload

**Problem**: The editor exposes TOO MANY controls at once, making it unclear what affects what. This contributes to bugs and user confusion.

### Current State (From Screenshots)

**What the editor shows for a single caption**:
1. **Timing** (Start/End inputs)
2. **Operations** (Add, Delete, Split, Merge buttons)
3. **Position** section:
   - Drag on video toggle
   - 9-button alignment grid (1-9)
   - X/Y pixel inputs
   - "Clear" button
4. **Style** section:
   - Font name input
   - Size, Outline, Shadow, Spacing inputs
   - 4 color pickers (Primary, Highlight, Outline, Shadow)
   - Bold, Italic, Underline toggles
5. **Caption text** textarea

### The Confusion

| Control | Scope | Effect | User Confusion |
|---------|-------|--------|----------------|
| **Style section** | Global | Changes ALL captions using this style | ‚ö†Ô∏è User thinks it only affects selected caption |
| **Position X/Y** | Per-caption | Adds `\pos(x,y)` inline override | ‚ö†Ô∏è Unclear this is an override |
| **Alignment grid** | Per-caption | Adds `\an#` inline override | ‚ö†Ô∏è Unclear this is an override |
| **Caption text** | Per-caption | Local change | ‚úÖ Clear |
| **Timing** | Per-caption | Local change | ‚úÖ Clear |

**Root Issue**: The editor mixes THREE levels of control without clear separation:
1. **Global style** (affects all captions with same style)
2. **Per-caption overrides** (inline ASS tags like `\pos`, `\an`, `\fs`, `\c`)
3. **Per-caption content** (text, timing)

### Why This Causes Bugs

1. **User edits "Size" in Style section**:
   - Expects: Only selected caption changes
   - Reality: ALL captions with "TikTok" style change
   - User doesn't understand why other captions changed

2. **User expects Position to persist**:
   - Edits position with drag or X/Y inputs
   - Clicks Split/Merge
   - **Bug**: Split/Merge lose the `\pos()` tag
   - User's positioning disappears

3. **Inline ASS styling is hidden**:
   - Generated captions have focus words: `{\fs70\c&H00FFFF&}important{\r}`
   - This styling is NOT shown in the Style UI
   - User edits text ‚Üí inline tags lost ‚Üí focus styling gone
   - User doesn't know why video looks different

### Recommended UX Redesign

**Simple Mode (Default)**:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Caption #1                          ‚îÇ
‚îÇ 00:00.03 ‚Üí 00:02.10                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [Text Editor]                       ‚îÇ
‚îÇ Hey my name is Poulomi Kha.         ‚îÇ
‚îÇ                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [Add]  [Delete]  [Split]  [Merge]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Position: [Bottom Center ‚ñº]         ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ ‚öôÔ∏è Advanced Options ‚ñº               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Advanced Mode (Expandable)**:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚öôÔ∏è Advanced Options ‚ñ≤               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚ñ° Override position                 ‚îÇ
‚îÇ   X: [540] Y: [960]                 ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ ‚ñ° Override style                    ‚îÇ
‚îÇ   Font: [Impact]  Size: [60]        ‚îÇ
‚îÇ   Outline: [4]  Shadow: [2]         ‚îÇ
‚îÇ   Color: [‚ñ†] Outline: [‚ñ†]           ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ üìù Edit ASS Tags Directly           ‚îÇ
‚îÇ   {\k18}Hey{\k14}my{\k26}name...    ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ üé® Edit Global Style                ‚îÇ
‚îÇ   (Opens style editor modal)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Benefits**:
- ‚úÖ Clear separation: per-caption vs global
- ‚úÖ Advanced features hidden until needed
- ‚úÖ Inline ASS tags visible and editable
- ‚úÖ Less overwhelming for basic edits
- ‚úÖ Power users can access advanced features

### How This Relates to Bugs

The current UX complexity contributes to bugs because:

1. **Split/Merge operations** don't know what to do with inline overrides
   - Should they preserve `\pos()`? `\an#`? `\fs#`?
   - Current code ignores them ‚Üí data loss

2. **Style editing** is confusing
   - User changes Size to 70
   - All captions change
   - User tries to undo ‚Üí can't (no per-caption history)

3. **No visual indication** of inline overrides
   - User doesn't know a caption has `\fs70` override
   - Edits text ‚Üí override lost
   - No way to see or recover it

### Proposed Solution

**Phase 1: Fix bugs without UX changes**
- Fix serializeStyle() extra comma
- Fix Split/Merge to preserve inline tags
- Add validation before compose

**Phase 2: UX improvements (future)**
- Collapse advanced options by default
- Show "Override active" badges when caption has inline tags
- Separate "Edit Text" from "Edit Style"
- Add "Edit Global Style" modal
- Show raw ASS tags in expandable section

---

## 7. Recommended Fixes (Priority Order)

### ‚úÖ Priority 1: Fix serializeStyle() [CRITICAL]

**File**: `lib/captions/ass-parser.ts:494-520`

**Current**:
```typescript
function serializeStyle(style: ASSStyle): string {
  return [
    'Style:',
    style.Name,
    style.Fontname,
    // ...
  ].join(',')
}
```

**Fixed**:
```typescript
function serializeStyle(style: ASSStyle): string {
  const values = [
    style.Name,
    style.Fontname,
    style.Fontsize,
    style.PrimaryColour,
    style.SecondaryColour,
    style.OutlineColour,
    style.BackColour,
    style.Bold,
    style.Italic,
    style.Underline,
    style.StrikeOut,
    style.ScaleX,
    style.ScaleY,
    style.Spacing,
    style.Angle,
    style.BorderStyle,
    style.Outline,
    style.Shadow,
    style.Alignment,
    style.MarginL,
    style.MarginR,
    style.MarginV,
    style.Encoding,
  ].join(',')

  return `Style: ${values}`  // ‚Üê Space after colon, no comma before Name
}
```

---

### ‚úÖ Priority 2: Fix Split/Merge Operations to Preserve Tags

**File**: `components/studio/ASSEditorModal.tsx:544-608`

**Fix Split Operation (line 544-587)**:

**Current**:
```typescript
const handleSplitCaption = () => {
  // ... split logic ...
  const updatedFirst: ParsedCaption = {
    ...caption,
    end: splitTime,
    text: firstText,       // ‚Üê BUG: Plain text
    plainText: firstText,
  }
  const updatedSecond: ParsedCaption = {
    ...caption,
    start: splitTime,
    text: secondText,      // ‚Üê BUG: Plain text
    plainText: secondText,
  }
  // ...
}
```

**Fixed**:
```typescript
const handleSplitCaption = () => {
  if (!state.parsed || state.selectedCaptionIndex === null) return
  const index = state.selectedCaptionIndex
  const captions = [...state.parsed.captions]
  const targetIndex = captions.findIndex((caption) => caption.index === index)
  if (targetIndex === -1) return
  const caption = captions[targetIndex]

  const minGap = 0.1
  let splitTime = state.currentTime
  if (splitTime <= caption.start + minGap || splitTime >= caption.end - minGap) {
    splitTime = caption.start + (caption.end - caption.start) / 2
  }

  const words = assTextToPlain(caption.text).trim().split(/\s+/).filter(Boolean)
  let firstText = caption.plainText || caption.text
  let secondText = caption.plainText || caption.text
  if (words.length >= 2) {
    const midpoint = Math.ceil(words.length / 2)
    firstText = words.slice(0, midpoint).join(' ')
    secondText = words.slice(midpoint).join(' ')
  } else if (words.length === 1) {
    const text = words[0]
    const mid = Math.ceil(text.length / 2)
    firstText = text.slice(0, mid)
    secondText = text.slice(mid)
  }

  // ‚úÖ FIX: Rebuild ASS text with tags preserved
  const firstTextWithTags = rebuildASSText(firstText, caption.text)
  const secondTextWithTags = rebuildASSText(secondText, caption.text)

  const updatedFirst: ParsedCaption = {
    ...caption,
    end: splitTime,
    text: firstTextWithTags,   // ‚Üê With tags
    plainText: firstText,
  }
  const updatedSecond: ParsedCaption = {
    ...caption,
    start: splitTime,
    text: secondTextWithTags,  // ‚Üê With tags
    plainText: secondText,
  }

  captions.splice(targetIndex, 1, updatedFirst, updatedSecond)
  const reindexed = reindexCaptions(captions)
  updateCaptions(reindexed, Math.min(targetIndex + 1, reindexed.length - 1))
}
```

**Fix Merge Operation (line 589-608)**:

**Current**:
```typescript
const handleMergeCaption = () => {
  // ...
  const mergedText = `${current.plainText || current.text} ${next.plainText || next.text}`.trim()
  const merged: ParsedCaption = {
    ...current,
    end: next.end,
    text: mergedText,      // ‚Üê BUG: Plain text
    plainText: mergedText,
  }
  // ...
}
```

**Fixed**:
```typescript
const handleMergeCaption = () => {
  if (!state.parsed || state.selectedCaptionIndex === null) return
  const captions = [...state.parsed.captions]
  const targetIndex = captions.findIndex(
    (caption) => caption.index === state.selectedCaptionIndex
  )
  if (targetIndex === -1 || targetIndex === captions.length - 1) return

  const current = captions[targetIndex]
  const next = captions[targetIndex + 1]

  const mergedPlainText = `${current.plainText || current.text} ${next.plainText || next.text}`.trim()

  // ‚úÖ FIX: Combine original texts and rebuild with tags
  const combinedOriginal = `${current.text} ${next.text}`
  const mergedTextWithTags = rebuildASSText(mergedPlainText, combinedOriginal)

  const merged: ParsedCaption = {
    ...current,
    end: next.end,
    text: mergedTextWithTags,  // ‚Üê With tags preserved
    plainText: mergedPlainText,
  }

  captions.splice(targetIndex, 2, merged)
  const reindexed = reindexCaptions(captions)
  updateCaptions(reindexed, Math.min(targetIndex, reindexed.length - 1))
}
```

**Note**: Don't forget to import `rebuildASSText` at the top of ASSEditorModal.tsx:
```typescript
import { rebuildASSText } from '@/lib/captions/ass-parser'
```

---

### ‚úÖ Priority 3: Improve rebuildASSText Logic

**File**: `lib/captions/ass-parser.ts:328-395`

**Issues**:
1. Early return when text matches (line 331-333) is good
2. But when text differs, logic for preserving karaoke structure is fragile
3. Word count mismatch causes fallback to plain text

**Improvements Needed**:
```typescript
export function rebuildASSText(plainText: string, originalText: string): string {
  const normalizedPlain = plainText.replace(/\r\n/g, '\n')
  const displayPlain = assTextToPlain(originalText)

  // If text unchanged, return original (with all tags)
  if (normalizedPlain === displayPlain) {
    return originalText
  }

  const safePlain = normalizedPlain.replace(/\n/g, '\\N')

  // Extract positioning/alignment overrides (ALWAYS preserve these)
  const prefixMatch = originalText.match(/^(\{[^}]*\})+/)
  const prefix = prefixMatch ? prefixMatch[0] : ''

  const overrideTags: string[] = []
  const alignmentMatch = prefix.match(/\\an\d+/gi)
  if (alignmentMatch) {
    overrideTags.push(...alignmentMatch)
  }
  const positionMatch = prefix.match(/\\pos\([^)]*\)/gi)
  if (positionMatch) {
    overrideTags.push(...positionMatch)
  }

  const overridePrefix = overrideTags.length ? `{${overrideTags.join('')}}` : ''

  // Extract karaoke segments
  const karaokeSegments = extractKaraokeSegments(originalText)

  if (karaokeSegments.length === 0) {
    // No karaoke in original ‚Üí return plain text with overrides
    return `${overridePrefix}${safePlain}`
  }

  // Try to preserve karaoke structure
  const words = safePlain.trim().split(/\s+/).filter(Boolean)

  // If word count matches, redistribute timing proportionally
  if (words.length === karaokeSegments.length) {
    const rebuilt = words.map((word, index) => {
      const segment = karaokeSegments[index]
      const spacer = index === 0 ? '' : ' '
      const tagContent = segment.tagContent
      const postTags = segment.postTags ? `{${segment.postTags}}` : ''
      return `{${tagContent}}${spacer}${word}${postTags}`
    }).join('')

    return `${overridePrefix}${rebuilt}`
  }

  // Word count mismatch ‚Üí distribute timing by character length
  const baseDurations = karaokeSegments.map(s => s.duration ?? 0)
  const totalDuration = baseDurations.reduce((sum, v) => sum + v, 0)
  const durations = distributeKaraokeDurations(words, totalDuration || words.length * 10)

  const rebuilt = words.map((word, index) => {
    const spacer = index === 0 ? '' : ' '
    // Use first segment's style tags as template
    const template = karaokeSegments[0]
    const baseTag = template.tagContent.replace(/\\k\d+/i, `\\k${durations[index]}`)
    const postTags = template.postTags ? `{${template.postTags}}` : ''
    return `{${baseTag}}${spacer}${word}${postTags}`
  }).join('')

  return `${overridePrefix}${rebuilt}`
}
```

---

### ‚úÖ Priority 4: Add Validation Before Compose

**File**: `app/api/video/compose/route.ts:88-97`

**Add ASS validation**:
```typescript
// After resolving subtitles URL
if (resolvedSubtitlesUrl) {
  // Download and validate ASS before sending to FFmpeg
  const assResponse = await fetch(resolvedSubtitlesUrl)
  if (assResponse.ok) {
    const assContent = await assResponse.text()

    // Check for known bugs
    if (assContent.includes('Style:,')) {
      console.error('[Video Compose] ASS has malformed Style line')
      return NextResponse.json(
        { error: 'ASS caption file is malformed. Please re-save captions.' },
        { status: 400 }
      )
    }

    // Count karaoke tags
    const karaokeCount = (assContent.match(/\\k\d+/g) || []).length
    if (karaokeCount === 0) {
      console.warn('[Video Compose] ASS has no karaoke tags - captions may be static')
    }
  }
}
```

---

### ‚úÖ Priority 5: Better Error Feedback in Editor

**File**: `components/studio/ASSEditorModal.tsx:355-386`

**Current**: Upload failure shows toast but doesn't block

**Improved**:
```typescript
const handleSaveDraft = async () => {
  if (!state.parsed) return

  try {
    const content = serializeASS(state.parsed)

    // Validate before saving
    if (content.includes('Style:,')) {
      toast({
        title: 'Serialization Error',
        description: 'Caption format is malformed. Please reload editor.',
        variant: 'destructive',
      })
      return
    }

    // Save to localStorage
    const payload = {
      assUrl,
      storageKey,
      content,
      updatedAt: new Date().toISOString(),
    }
    localStorage.setItem(getDraftKey(projectId, storageKey), JSON.stringify(payload))

    // Show loading state
    dispatch({ type: 'SET_SAVING', saving: true })

    // Upload to storage (blocking)
    const response = await fetch('/api/captions/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        storagePath: storageKey,
        content,
      }),
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error || 'Failed to save captions')
    }

    const data = await response.json()

    // Update URL in parent
    if (data.assUrl) {
      _onSave(data.assUrl)
    }

    dispatch({ type: 'SAVE_SUCCESS' })

    toast({
      title: 'Captions Saved',
      description: 'Your edits have been saved to storage.',
    })
  } catch (error) {
    dispatch({ type: 'SET_SAVING', saving: false })
    console.error('Failed to save draft:', error)
    toast({
      title: 'Save Failed',
      description: error instanceof Error ? error.message : 'Unable to save captions',
      variant: 'destructive',
    })
  }
}
```

---

## 7. Verification Steps

### Step 1: Test serializeStyle Fix

```typescript
// Test in browser console
import { parseASS, serializeASS } from '@/lib/captions/ass-parser'

const testASS = `[Script Info]
Title: Test

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TikTok,Impact,60,&H00FFFFFF&,&H0040DDFE&,&H00000000&,&H80000000&,-1,0,0,0,100,100,0,0,1,4,2,2,50,50,50,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.00,TikTok,,0,0,0,,Test`

const parsed = parseASS(testASS)
const serialized = serializeASS(parsed)

console.log(serialized)
// Should output: "Style: TikTok,Impact,..."
// NOT: "Style:,TikTok,Impact,..."
```

### Step 2: Test rebuildASSText

```typescript
import { rebuildASSText } from '@/lib/captions/ass-parser'

const original = '{\\k18}Hey{\\k14}my{\\k26}name{\\r\\k8\\fs70\\c&H00FFFF&}is{\\r}{\\k52}Pulomi,'
const newPlain = 'Hey my name is Poulomi Kha'

const rebuilt = rebuildASSText(newPlain, original)
console.log(rebuilt)

// Should preserve karaoke structure:
// {\\k??}Hey{\\k??}my{\\k??}name{\\r\\k??\\fs70\\c&H00FFFF&}is{\\r}{\\k??}Pulomi{\\k??}Kha
```

### Step 3: Test FFmpeg with Fixed ASS

```bash
# Download saved ASS from storage
curl -o test.ass "https://..."

# Check for formatting issues
grep "Style:" test.ass
# Should show: "Style: TikTok,..."
# NOT: "Style:,TikTok,..."

# Test with FFmpeg locally
ffmpeg -i background.mp4 -vf ass=test.ass -t 5 output.mp4

# Check ffmpeg logs for ASS parsing warnings
# Should see clean parse, no errors
```

---

## 8. Root Cause Summary

| Bug | Impact | Root Cause |
|-----|--------|------------|
| **Extra comma in Style line** | ‚≠ê‚≠ê‚≠ê CRITICAL | `serializeStyle()` joins array including `'Style:'` as first element |
| **Split/Merge lose tags** | ‚≠ê‚≠ê‚≠ê CRITICAL | Operations set plain text without calling `rebuildASSText()` |
| **Vague FFmpeg errors** | ‚≠ê‚≠ê HIGH | No ASS validation before processing ‚Üí cryptic error messages |
| **Silent save failures** | ‚≠ê‚≠ê HIGH | Async upload doesn't block, localStorage ‚â† storage |
| **Preview vs video mismatch** | ‚≠ê‚≠ê HIGH | Editor renders from memory, FFmpeg reads malformed file |
| **UX complexity** | ‚≠ê‚≠ê HIGH | Global vs per-caption controls mixed ‚Üí user confusion ‚Üí data loss |
| **rebuildASSText fragility** | ‚≠ê MEDIUM | Word count logic fails, fallback to plain text |

**Key Finding**: Text editing via textarea IS correct (calls `rebuildASSText()`). The bug happens when user clicks Split or Merge buttons.

---

## 9. Long-term Improvements

### Suggestion 1: ASS Round-trip Testing

Add automated tests:
```typescript
// lib/captions/__tests__/roundtrip.test.ts
test('ASS serialization preserves all tags', () => {
  const original = readFileSync('fixtures/tiktok-karaoke.ass', 'utf-8')
  const parsed = parseASS(original)
  const serialized = serializeASS(parsed)
  const reparsed = parseASS(serialized)

  expect(reparsed.styles).toEqual(parsed.styles)
  expect(reparsed.captions).toEqual(parsed.captions)
})
```

### Suggestion 2: ASS Linter

Add validation helper:
```typescript
// lib/captions/ass-validator.ts
export function validateASS(content: string): { valid: boolean; errors: string[] } {
  const errors: string[] = []

  if (content.includes('Style:,')) {
    errors.push('Style line has extra comma after colon')
  }

  const dialogues = content.match(/^Dialogue: .+$/gm) || []
  dialogues.forEach((line, i) => {
    if (!line.includes('{\\k')) {
      errors.push(`Dialogue ${i} missing karaoke tags`)
    }
  })

  return { valid: errors.length === 0, errors }
}
```

### Suggestion 3: Editor State Snapshots

Add undo/redo:
```typescript
// Store snapshots of state.parsed every 5 edits
// Allow user to revert if they lose tags
```

---

## 10. References

### Key Files

| File | Purpose |
|------|---------|
| `lib/captions/ass-generator.ts` | Generates initial ASS from WhisperX |
| `lib/captions/ass-parser.ts` | Parses/serializes ASS ‚ö†Ô∏è **BUGS HERE** |
| `lib/captions/ass-text.ts` | Strips ASS tags for display |
| `components/studio/ASSEditorModal.tsx` | Main editor component |
| `components/studio/editor/VideoPlayer.tsx` | Preview renderer |
| `app/api/captions/save/route.ts` | Saves ASS to storage |
| `app/api/video/compose/route.ts` | Composes video with captions |
| `modal_apis/ffmpeg_api/src/ffmpeg_ops.py` | FFmpeg subtitle overlay |

### ASS Format Specs

- [ASS Format Documentation](http://www.tcax.org/docs/ass-specs.htm)
- FFmpeg ASS Filter: `ffmpeg -h filter=ass`

---

## 11. Immediate Action Plan

**Before making changes:**
1. Read `components/studio/editor/EditorSidebar.tsx` to see text update flow
2. Add console.log to trace text updates through reducer
3. Download a saved ASS file from storage to verify bugs

**Fixes to implement:**
1. ‚úÖ Fix `serializeStyle()` - remove extra comma
2. ‚úÖ Update `UPDATE_CAPTION` reducer to call `rebuildASSText()`
3. ‚úÖ Make save draft blocking with clear error feedback
4. ‚úÖ Add ASS validation before sending to FFmpeg

**Testing:**
1. Generate captions
2. Edit text in editor
3. Save draft
4. Download ASS from storage
5. Verify Style lines are correct
6. Verify Dialogue lines have karaoke tags
7. Compose video
8. Compare preview vs final video

---

**Status**: Ready for implementation
**Estimated Time**: 2-3 hours for all fixes + testing
**Risk Level**: Low (fixes are isolated, well-understood)
