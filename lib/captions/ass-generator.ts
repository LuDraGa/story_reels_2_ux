/**
 * ASS (Advanced SubStation Alpha) Caption Generator
 *
 * Generates ASS subtitle files with karaoke word-highlighting effects from
 * WhisperX transcription data with word-level timestamps.
 *
 * Key Features:
 * - Karaoke timing (\k tags) for word-by-word highlighting
 * - Multi-line grouping (5 words per line default)
 * - Focus word inline styling (AI-detected important words)
 * - Multiple style presets (TikTok, Instagram, YouTube)
 */

import type { TranscriptionResponse, TranscriptionWord } from '@/lib/api/whisperx'
import {
  getPreset,
  formatStyleLine,
  formatASSTime,
  calculateKaraokeDuration,
  type PresetInfo,
  type ASSStyle,
} from './ass-presets'

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * ASS generation options
 */
export interface ASSOptions {
  /** Preset ID (tiktok, instagram, youtube) */
  preset?: string
  /** Word indices to emphasize (0-indexed) */
  focusWords?: number[]
  /** Maximum words per caption line */
  maxWordsPerLine?: number
  /** Script title (appears in ASS header) */
  title?: string
  /** Video resolution width */
  videoWidth?: number
  /** Video resolution height */
  videoHeight?: number
}

/**
 * ASS dialogue event (one caption)
 */
interface ASSDialogue {
  start: number // seconds
  end: number // seconds
  style: string // Style name
  text: string // Caption text with karaoke tags
}

// ============================================================================
// ASS Header Generation
// ============================================================================

/**
 * Generate ASS script header with metadata
 */
function generateASSHeader(options: ASSOptions): string {
  const title = options.title || 'Reel Story Studio Captions'
  const videoWidth = options.videoWidth || 1080
  const videoHeight = options.videoHeight || 1920

  return `[Script Info]
; Script generated by Reel Story Studio
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709
PlayResX: ${videoWidth}
PlayResY: ${videoHeight}

`
}

/**
 * Generate [V4+ Styles] section
 */
function generateASSStyles(preset: PresetInfo): string {
  let output = '[V4+ Styles]\n'
  output += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n'

  // Add main style
  output += formatStyleLine(preset.style) + '\n'

  // Add focus style if available
  if (preset.focusStyle) {
    output += formatStyleLine(preset.focusStyle) + '\n'
  }

  output += '\n'
  return output
}

/**
 * Generate [Events] section header
 */
function generateASSEventsHeader(): string {
  return `[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text

`
}

// ============================================================================
// Karaoke Timing Generation
// ============================================================================

/**
 * Convert WhisperX word to karaoke tag
 *
 * @param word - Word with timing
 * @param isFocus - Whether this is a focus word
 * @returns Karaoke-tagged word (e.g., "{\k50}hello")
 */
function wordToKaraoke(word: TranscriptionWord, isFocus: boolean = false): string {
  const duration = calculateKaraokeDuration(word.start, word.end)
  const text = word.word

  if (isFocus) {
    // Focus words use inline style override + karaoke
    return `{\\r\\k${duration}\\fs70\\c&H00FFFF&}${text}{\\r}`
  }

  return `{\\k${duration}}${text}`
}

/**
 * Group words into multi-line captions
 *
 * Creates caption blocks with multiple words, each with individual karaoke timing.
 * Words are grouped by proximity and max words per line.
 *
 * @param words - All words from transcription
 * @param maxWordsPerLine - Maximum words per caption
 * @param focusIndices - Set of word indices to emphasize
 * @returns Array of dialogue events
 */
function groupWordsIntoDialogues(
  words: TranscriptionWord[],
  maxWordsPerLine: number,
  focusIndices: Set<number>,
  styleName: string
): ASSDialogue[] {
  const dialogues: ASSDialogue[] = []
  let currentGroup: TranscriptionWord[] = []
  let currentFocusWords: boolean[] = []

  for (let i = 0; i < words.length; i++) {
    const word = words[i]
    const isFocus = focusIndices.has(i)

    currentGroup.push(word)
    currentFocusWords.push(isFocus)

    // Create dialogue when we hit max words or it's the last word
    if (currentGroup.length >= maxWordsPerLine || i === words.length - 1) {
      const start = currentGroup[0].start
      const end = currentGroup[currentGroup.length - 1].end

      // Generate karaoke text
      const karaokeWords = currentGroup.map((w, idx) =>
        wordToKaraoke(w, currentFocusWords[idx])
      )
      const text = karaokeWords.join('')

      dialogues.push({
        start,
        end,
        style: styleName,
        text,
      })

      // Reset for next group
      currentGroup = []
      currentFocusWords = []
    }
  }

  return dialogues
}

/**
 * Alternative: Group words by sentence boundaries
 *
 * More natural grouping based on punctuation and pauses.
 * Falls back to word count if no punctuation detected.
 */
function groupWordsBySentence(
  words: TranscriptionWord[],
  maxWordsPerLine: number,
  focusIndices: Set<number>,
  styleName: string
): ASSDialogue[] {
  const dialogues: ASSDialogue[] = []
  let currentGroup: TranscriptionWord[] = []
  let currentFocusWords: boolean[] = []

  for (let i = 0; i < words.length; i++) {
    const word = words[i]
    const isFocus = focusIndices.has(i)

    currentGroup.push(word)
    currentFocusWords.push(isFocus)

    // Check for sentence ending punctuation
    const hasPunctuation = /[.!?]/.test(word.word)
    const nextWordGap = i < words.length - 1 ? words[i + 1].start - word.end : 0
    const hasLongPause = nextWordGap > 0.5 // 500ms+ pause
    const isLastWord = i === words.length - 1
    const maxWordsReached = currentGroup.length >= maxWordsPerLine

    if (hasPunctuation || hasLongPause || isLastWord || maxWordsReached) {
      const start = currentGroup[0].start
      const end = currentGroup[currentGroup.length - 1].end

      // Generate karaoke text
      const karaokeWords = currentGroup.map((w, idx) =>
        wordToKaraoke(w, currentFocusWords[idx])
      )
      const text = karaokeWords.join('')

      dialogues.push({
        start,
        end,
        style: styleName,
        text,
      })

      // Reset for next group
      currentGroup = []
      currentFocusWords = []
    }
  }

  return dialogues
}

// ============================================================================
// Dialogue Event Formatting
// ============================================================================

/**
 * Format a single ASS dialogue event
 *
 * Format: Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
 */
function formatDialogue(dialogue: ASSDialogue): string {
  const start = formatASSTime(dialogue.start)
  const end = formatASSTime(dialogue.end)
  const layer = 0
  const name = ''
  const marginL = 0
  const marginR = 0
  const marginV = 0
  const effect = ''

  return `Dialogue: ${layer},${start},${end},${dialogue.style},${name},${marginL},${marginR},${marginV},${effect},${dialogue.text}`
}

// ============================================================================
// Main Generation Function
// ============================================================================

/**
 * Generate ASS subtitle file from WhisperX transcription
 *
 * @param transcription - WhisperX transcription response
 * @param options - ASS generation options
 * @returns Complete ASS file content as string
 *
 * @example
 * const transcription = await callWhisperXTranscribe(...)
 * const ass = generateASS(transcription, {
 *   preset: 'tiktok',
 *   focusWords: [5, 12, 25], // Emphasize words at these indices
 *   maxWordsPerLine: 5,
 * })
 * fs.writeFileSync('captions.ass', ass)
 */
export function generateASS(
  transcription: TranscriptionResponse,
  options: ASSOptions = {}
): string {
  // Get preset
  const presetId = options.preset || 'tiktok'
  const preset = getPreset(presetId)

  // Get focus words
  const focusIndices = new Set(options.focusWords || [])

  // Get max words per line
  const maxWordsPerLine = options.maxWordsPerLine || 5

  // Extract all words from segments
  const allWords: TranscriptionWord[] = []
  for (const segment of transcription.segments) {
    allWords.push(...segment.words)
  }

  // Generate dialogues with karaoke timing
  const dialogues = groupWordsBySentence(
    allWords,
    maxWordsPerLine,
    focusIndices,
    preset.style.Name
  )

  // Build ASS file
  let ass = ''
  ass += generateASSHeader(options)
  ass += generateASSStyles(preset)
  ass += generateASSEventsHeader()

  // Add all dialogue events
  for (const dialogue of dialogues) {
    ass += formatDialogue(dialogue) + '\n'
  }

  return ass
}

// ============================================================================
// Export Utilities
// ============================================================================

/**
 * Save ASS to file (Node.js only)
 *
 * @param ass - ASS content
 * @param filepath - Output file path
 */
export async function saveASS(ass: string, filepath: string): Promise<void> {
  // Only available in Node.js environment
  if (typeof window !== 'undefined') {
    throw new Error('saveASS is only available in Node.js environment')
  }

  const fs = await import('fs')
  await fs.promises.writeFile(filepath, ass, 'utf-8')
}

/**
 * Convert ASS to data URL for browser download
 *
 * @param ass - ASS content
 * @returns Data URL
 */
export function assToDataURL(ass: string): string {
  const base64 = Buffer.from(ass, 'utf-8').toString('base64')
  return `data:text/plain;base64,${base64}`
}

/**
 * Get ASS as Blob for upload
 *
 * @param ass - ASS content
 * @returns Blob
 */
export function assToBlob(ass: string): Blob {
  return new Blob([ass], { type: 'text/plain;charset=utf-8' })
}

/**
 * Estimate ASS file size in bytes
 *
 * @param transcription - WhisperX transcription
 * @returns Estimated file size
 */
export function estimateASSSize(transcription: TranscriptionResponse): number {
  // Rough estimate: header (~500 bytes) + ~100 bytes per word
  const wordCount = transcription.segments.reduce(
    (sum, seg) => sum + seg.words.length,
    0
  )
  return 500 + wordCount * 100
}

/**
 * Validate ASS content
 *
 * Basic validation to ensure ASS file is well-formed
 *
 * @param ass - ASS content
 * @returns True if valid, throws error otherwise
 */
export function validateASS(ass: string): boolean {
  if (!ass.includes('[Script Info]')) {
    throw new Error('Invalid ASS: Missing [Script Info] section')
  }
  if (!ass.includes('[V4+ Styles]')) {
    throw new Error('Invalid ASS: Missing [V4+ Styles] section')
  }
  if (!ass.includes('[Events]')) {
    throw new Error('Invalid ASS: Missing [Events] section')
  }
  if (!ass.includes('Dialogue:')) {
    throw new Error('Invalid ASS: No dialogue events found')
  }
  return true
}

// ============================================================================
// Statistics & Debugging
// ============================================================================

/**
 * Get ASS generation statistics
 */
export interface ASSStats {
  totalWords: number
  totalCaptions: number
  totalDuration: number
  averageWordsPerCaption: number
  focusWordCount: number
  preset: string
}

/**
 * Extract statistics from ASS generation
 */
export function getASSStats(
  transcription: TranscriptionResponse,
  options: ASSOptions
): ASSStats {
  const wordCount = transcription.segments.reduce(
    (sum, seg) => sum + seg.words.length,
    0
  )

  const maxWordsPerLine = options.maxWordsPerLine || 5
  const captionCount = Math.ceil(wordCount / maxWordsPerLine)

  return {
    totalWords: wordCount,
    totalCaptions: captionCount,
    totalDuration: transcription.duration,
    averageWordsPerCaption: wordCount / captionCount,
    focusWordCount: options.focusWords?.length || 0,
    preset: options.preset || 'tiktok',
  }
}
